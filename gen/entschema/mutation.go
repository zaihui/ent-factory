// Code generated by ent, DO NOT EDIT.

package entschema

import (
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"github.com/zaihui/ent-factory/gen/entschema/predicate"
	"github.com/zaihui/ent-factory/gen/entschema/test"
	"github.com/zaihui/ent-factory/spec/schema"

	"entgo.io/ent"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeTest = "Test"
)

// TestMutation represents an operation that mutates the Test nodes in the graph.
type TestMutation struct {
	config
	op                    Op
	typ                   string
	id                    *int
	uid                   *string
	created_at            *time.Time
	updated_at            *time.Time
	deactivated_at        *time.Time
	name                  *string
	enable_takeaway       *bool
	phone                 *string
	announcement          *string
	enable_auto_accept    *bool
	delivery_configs      *schema.DeliveryConfig
	pay_configs           *schema.PayConfig
	print_times           *int
	addprint_times        *int
	ring_configs          *schema.RingConfig
	business_group_id     *int
	addbusiness_group_id  *int
	business_group_uid    *string
	dish_categories       *[]string
	appenddish_categories []string
	end_of_takeaway       *time.Time
	mode                  *int
	addmode               *int
	self_pickup_configs   *schema.SelfPickupConfig
	server_id             *int
	addserver_id          *int
	image                 *string
	address               *string
	latitude              *string
	longitude             *string
	banners               *schema.Banners
	sort                  *int
	addsort               *int
	pay_mode              *string
	dine_in_configs       *schema.DineInConfigs
	deals_config          *schema.DealsConfig
	print_config          *schema.PrintConfig
	clearedFields         map[string]struct{}
	done                  bool
	oldValue              func(context.Context) (*Test, error)
	predicates            []predicate.Test
}

var _ ent.Mutation = (*TestMutation)(nil)

// testOption allows management of the mutation configuration using functional options.
type testOption func(*TestMutation)

// newTestMutation creates new mutation for the Test entity.
func newTestMutation(c config, op Op, opts ...testOption) *TestMutation {
	m := &TestMutation{
		config:        c,
		op:            op,
		typ:           TypeTest,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTestID sets the ID field of the mutation.
func withTestID(id int) testOption {
	return func(m *TestMutation) {
		var (
			err   error
			once  sync.Once
			value *Test
		)
		m.oldValue = func(ctx context.Context) (*Test, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Test.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTest sets the old Test of the mutation.
func withTest(node *Test) testOption {
	return func(m *TestMutation) {
		m.oldValue = func(context.Context) (*Test, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TestMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TestMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("entschema: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Test entities.
func (m *TestMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TestMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TestMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Test.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUID sets the "uid" field.
func (m *TestMutation) SetUID(s string) {
	m.uid = &s
}

// UID returns the value of the "uid" field in the mutation.
func (m *TestMutation) UID() (r string, exists bool) {
	v := m.uid
	if v == nil {
		return
	}
	return *v, true
}

// OldUID returns the old "uid" field's value of the Test entity.
// If the Test object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TestMutation) OldUID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUID: %w", err)
	}
	return oldValue.UID, nil
}

// ResetUID resets all changes to the "uid" field.
func (m *TestMutation) ResetUID() {
	m.uid = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *TestMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *TestMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Test entity.
// If the Test object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TestMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *TestMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *TestMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *TestMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Test entity.
// If the Test object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TestMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *TestMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeactivatedAt sets the "deactivated_at" field.
func (m *TestMutation) SetDeactivatedAt(t time.Time) {
	m.deactivated_at = &t
}

// DeactivatedAt returns the value of the "deactivated_at" field in the mutation.
func (m *TestMutation) DeactivatedAt() (r time.Time, exists bool) {
	v := m.deactivated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeactivatedAt returns the old "deactivated_at" field's value of the Test entity.
// If the Test object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TestMutation) OldDeactivatedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeactivatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeactivatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeactivatedAt: %w", err)
	}
	return oldValue.DeactivatedAt, nil
}

// ClearDeactivatedAt clears the value of the "deactivated_at" field.
func (m *TestMutation) ClearDeactivatedAt() {
	m.deactivated_at = nil
	m.clearedFields[test.FieldDeactivatedAt] = struct{}{}
}

// DeactivatedAtCleared returns if the "deactivated_at" field was cleared in this mutation.
func (m *TestMutation) DeactivatedAtCleared() bool {
	_, ok := m.clearedFields[test.FieldDeactivatedAt]
	return ok
}

// ResetDeactivatedAt resets all changes to the "deactivated_at" field.
func (m *TestMutation) ResetDeactivatedAt() {
	m.deactivated_at = nil
	delete(m.clearedFields, test.FieldDeactivatedAt)
}

// SetName sets the "name" field.
func (m *TestMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *TestMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Test entity.
// If the Test object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TestMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *TestMutation) ResetName() {
	m.name = nil
}

// SetEnableTakeaway sets the "enable_takeaway" field.
func (m *TestMutation) SetEnableTakeaway(b bool) {
	m.enable_takeaway = &b
}

// EnableTakeaway returns the value of the "enable_takeaway" field in the mutation.
func (m *TestMutation) EnableTakeaway() (r bool, exists bool) {
	v := m.enable_takeaway
	if v == nil {
		return
	}
	return *v, true
}

// OldEnableTakeaway returns the old "enable_takeaway" field's value of the Test entity.
// If the Test object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TestMutation) OldEnableTakeaway(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEnableTakeaway is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEnableTakeaway requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEnableTakeaway: %w", err)
	}
	return oldValue.EnableTakeaway, nil
}

// ResetEnableTakeaway resets all changes to the "enable_takeaway" field.
func (m *TestMutation) ResetEnableTakeaway() {
	m.enable_takeaway = nil
}

// SetPhone sets the "phone" field.
func (m *TestMutation) SetPhone(s string) {
	m.phone = &s
}

// Phone returns the value of the "phone" field in the mutation.
func (m *TestMutation) Phone() (r string, exists bool) {
	v := m.phone
	if v == nil {
		return
	}
	return *v, true
}

// OldPhone returns the old "phone" field's value of the Test entity.
// If the Test object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TestMutation) OldPhone(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPhone is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPhone requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPhone: %w", err)
	}
	return oldValue.Phone, nil
}

// ResetPhone resets all changes to the "phone" field.
func (m *TestMutation) ResetPhone() {
	m.phone = nil
}

// SetAnnouncement sets the "announcement" field.
func (m *TestMutation) SetAnnouncement(s string) {
	m.announcement = &s
}

// Announcement returns the value of the "announcement" field in the mutation.
func (m *TestMutation) Announcement() (r string, exists bool) {
	v := m.announcement
	if v == nil {
		return
	}
	return *v, true
}

// OldAnnouncement returns the old "announcement" field's value of the Test entity.
// If the Test object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TestMutation) OldAnnouncement(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAnnouncement is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAnnouncement requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAnnouncement: %w", err)
	}
	return oldValue.Announcement, nil
}

// ResetAnnouncement resets all changes to the "announcement" field.
func (m *TestMutation) ResetAnnouncement() {
	m.announcement = nil
}

// SetEnableAutoAccept sets the "enable_auto_accept" field.
func (m *TestMutation) SetEnableAutoAccept(b bool) {
	m.enable_auto_accept = &b
}

// EnableAutoAccept returns the value of the "enable_auto_accept" field in the mutation.
func (m *TestMutation) EnableAutoAccept() (r bool, exists bool) {
	v := m.enable_auto_accept
	if v == nil {
		return
	}
	return *v, true
}

// OldEnableAutoAccept returns the old "enable_auto_accept" field's value of the Test entity.
// If the Test object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TestMutation) OldEnableAutoAccept(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEnableAutoAccept is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEnableAutoAccept requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEnableAutoAccept: %w", err)
	}
	return oldValue.EnableAutoAccept, nil
}

// ResetEnableAutoAccept resets all changes to the "enable_auto_accept" field.
func (m *TestMutation) ResetEnableAutoAccept() {
	m.enable_auto_accept = nil
}

// SetDeliveryConfigs sets the "delivery_configs" field.
func (m *TestMutation) SetDeliveryConfigs(sc schema.DeliveryConfig) {
	m.delivery_configs = &sc
}

// DeliveryConfigs returns the value of the "delivery_configs" field in the mutation.
func (m *TestMutation) DeliveryConfigs() (r schema.DeliveryConfig, exists bool) {
	v := m.delivery_configs
	if v == nil {
		return
	}
	return *v, true
}

// OldDeliveryConfigs returns the old "delivery_configs" field's value of the Test entity.
// If the Test object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TestMutation) OldDeliveryConfigs(ctx context.Context) (v schema.DeliveryConfig, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeliveryConfigs is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeliveryConfigs requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeliveryConfigs: %w", err)
	}
	return oldValue.DeliveryConfigs, nil
}

// ResetDeliveryConfigs resets all changes to the "delivery_configs" field.
func (m *TestMutation) ResetDeliveryConfigs() {
	m.delivery_configs = nil
}

// SetPayConfigs sets the "pay_configs" field.
func (m *TestMutation) SetPayConfigs(sc schema.PayConfig) {
	m.pay_configs = &sc
}

// PayConfigs returns the value of the "pay_configs" field in the mutation.
func (m *TestMutation) PayConfigs() (r schema.PayConfig, exists bool) {
	v := m.pay_configs
	if v == nil {
		return
	}
	return *v, true
}

// OldPayConfigs returns the old "pay_configs" field's value of the Test entity.
// If the Test object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TestMutation) OldPayConfigs(ctx context.Context) (v schema.PayConfig, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPayConfigs is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPayConfigs requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPayConfigs: %w", err)
	}
	return oldValue.PayConfigs, nil
}

// ResetPayConfigs resets all changes to the "pay_configs" field.
func (m *TestMutation) ResetPayConfigs() {
	m.pay_configs = nil
}

// SetPrintTimes sets the "print_times" field.
func (m *TestMutation) SetPrintTimes(i int) {
	m.print_times = &i
	m.addprint_times = nil
}

// PrintTimes returns the value of the "print_times" field in the mutation.
func (m *TestMutation) PrintTimes() (r int, exists bool) {
	v := m.print_times
	if v == nil {
		return
	}
	return *v, true
}

// OldPrintTimes returns the old "print_times" field's value of the Test entity.
// If the Test object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TestMutation) OldPrintTimes(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPrintTimes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPrintTimes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPrintTimes: %w", err)
	}
	return oldValue.PrintTimes, nil
}

// AddPrintTimes adds i to the "print_times" field.
func (m *TestMutation) AddPrintTimes(i int) {
	if m.addprint_times != nil {
		*m.addprint_times += i
	} else {
		m.addprint_times = &i
	}
}

// AddedPrintTimes returns the value that was added to the "print_times" field in this mutation.
func (m *TestMutation) AddedPrintTimes() (r int, exists bool) {
	v := m.addprint_times
	if v == nil {
		return
	}
	return *v, true
}

// ClearPrintTimes clears the value of the "print_times" field.
func (m *TestMutation) ClearPrintTimes() {
	m.print_times = nil
	m.addprint_times = nil
	m.clearedFields[test.FieldPrintTimes] = struct{}{}
}

// PrintTimesCleared returns if the "print_times" field was cleared in this mutation.
func (m *TestMutation) PrintTimesCleared() bool {
	_, ok := m.clearedFields[test.FieldPrintTimes]
	return ok
}

// ResetPrintTimes resets all changes to the "print_times" field.
func (m *TestMutation) ResetPrintTimes() {
	m.print_times = nil
	m.addprint_times = nil
	delete(m.clearedFields, test.FieldPrintTimes)
}

// SetRingConfigs sets the "ring_configs" field.
func (m *TestMutation) SetRingConfigs(sc schema.RingConfig) {
	m.ring_configs = &sc
}

// RingConfigs returns the value of the "ring_configs" field in the mutation.
func (m *TestMutation) RingConfigs() (r schema.RingConfig, exists bool) {
	v := m.ring_configs
	if v == nil {
		return
	}
	return *v, true
}

// OldRingConfigs returns the old "ring_configs" field's value of the Test entity.
// If the Test object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TestMutation) OldRingConfigs(ctx context.Context) (v schema.RingConfig, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRingConfigs is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRingConfigs requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRingConfigs: %w", err)
	}
	return oldValue.RingConfigs, nil
}

// ResetRingConfigs resets all changes to the "ring_configs" field.
func (m *TestMutation) ResetRingConfigs() {
	m.ring_configs = nil
}

// SetBusinessGroupID sets the "business_group_id" field.
func (m *TestMutation) SetBusinessGroupID(i int) {
	m.business_group_id = &i
	m.addbusiness_group_id = nil
}

// BusinessGroupID returns the value of the "business_group_id" field in the mutation.
func (m *TestMutation) BusinessGroupID() (r int, exists bool) {
	v := m.business_group_id
	if v == nil {
		return
	}
	return *v, true
}

// OldBusinessGroupID returns the old "business_group_id" field's value of the Test entity.
// If the Test object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TestMutation) OldBusinessGroupID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBusinessGroupID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBusinessGroupID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBusinessGroupID: %w", err)
	}
	return oldValue.BusinessGroupID, nil
}

// AddBusinessGroupID adds i to the "business_group_id" field.
func (m *TestMutation) AddBusinessGroupID(i int) {
	if m.addbusiness_group_id != nil {
		*m.addbusiness_group_id += i
	} else {
		m.addbusiness_group_id = &i
	}
}

// AddedBusinessGroupID returns the value that was added to the "business_group_id" field in this mutation.
func (m *TestMutation) AddedBusinessGroupID() (r int, exists bool) {
	v := m.addbusiness_group_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetBusinessGroupID resets all changes to the "business_group_id" field.
func (m *TestMutation) ResetBusinessGroupID() {
	m.business_group_id = nil
	m.addbusiness_group_id = nil
}

// SetBusinessGroupUID sets the "business_group_uid" field.
func (m *TestMutation) SetBusinessGroupUID(s string) {
	m.business_group_uid = &s
}

// BusinessGroupUID returns the value of the "business_group_uid" field in the mutation.
func (m *TestMutation) BusinessGroupUID() (r string, exists bool) {
	v := m.business_group_uid
	if v == nil {
		return
	}
	return *v, true
}

// OldBusinessGroupUID returns the old "business_group_uid" field's value of the Test entity.
// If the Test object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TestMutation) OldBusinessGroupUID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBusinessGroupUID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBusinessGroupUID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBusinessGroupUID: %w", err)
	}
	return oldValue.BusinessGroupUID, nil
}

// ResetBusinessGroupUID resets all changes to the "business_group_uid" field.
func (m *TestMutation) ResetBusinessGroupUID() {
	m.business_group_uid = nil
}

// SetDishCategories sets the "dish_categories" field.
func (m *TestMutation) SetDishCategories(s []string) {
	m.dish_categories = &s
	m.appenddish_categories = nil
}

// DishCategories returns the value of the "dish_categories" field in the mutation.
func (m *TestMutation) DishCategories() (r []string, exists bool) {
	v := m.dish_categories
	if v == nil {
		return
	}
	return *v, true
}

// OldDishCategories returns the old "dish_categories" field's value of the Test entity.
// If the Test object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TestMutation) OldDishCategories(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDishCategories is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDishCategories requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDishCategories: %w", err)
	}
	return oldValue.DishCategories, nil
}

// AppendDishCategories adds s to the "dish_categories" field.
func (m *TestMutation) AppendDishCategories(s []string) {
	m.appenddish_categories = append(m.appenddish_categories, s...)
}

// AppendedDishCategories returns the list of values that were appended to the "dish_categories" field in this mutation.
func (m *TestMutation) AppendedDishCategories() ([]string, bool) {
	if len(m.appenddish_categories) == 0 {
		return nil, false
	}
	return m.appenddish_categories, true
}

// ResetDishCategories resets all changes to the "dish_categories" field.
func (m *TestMutation) ResetDishCategories() {
	m.dish_categories = nil
	m.appenddish_categories = nil
}

// SetEndOfTakeaway sets the "end_of_takeaway" field.
func (m *TestMutation) SetEndOfTakeaway(t time.Time) {
	m.end_of_takeaway = &t
}

// EndOfTakeaway returns the value of the "end_of_takeaway" field in the mutation.
func (m *TestMutation) EndOfTakeaway() (r time.Time, exists bool) {
	v := m.end_of_takeaway
	if v == nil {
		return
	}
	return *v, true
}

// OldEndOfTakeaway returns the old "end_of_takeaway" field's value of the Test entity.
// If the Test object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TestMutation) OldEndOfTakeaway(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEndOfTakeaway is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEndOfTakeaway requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEndOfTakeaway: %w", err)
	}
	return oldValue.EndOfTakeaway, nil
}

// ClearEndOfTakeaway clears the value of the "end_of_takeaway" field.
func (m *TestMutation) ClearEndOfTakeaway() {
	m.end_of_takeaway = nil
	m.clearedFields[test.FieldEndOfTakeaway] = struct{}{}
}

// EndOfTakeawayCleared returns if the "end_of_takeaway" field was cleared in this mutation.
func (m *TestMutation) EndOfTakeawayCleared() bool {
	_, ok := m.clearedFields[test.FieldEndOfTakeaway]
	return ok
}

// ResetEndOfTakeaway resets all changes to the "end_of_takeaway" field.
func (m *TestMutation) ResetEndOfTakeaway() {
	m.end_of_takeaway = nil
	delete(m.clearedFields, test.FieldEndOfTakeaway)
}

// SetMode sets the "mode" field.
func (m *TestMutation) SetMode(i int) {
	m.mode = &i
	m.addmode = nil
}

// Mode returns the value of the "mode" field in the mutation.
func (m *TestMutation) Mode() (r int, exists bool) {
	v := m.mode
	if v == nil {
		return
	}
	return *v, true
}

// OldMode returns the old "mode" field's value of the Test entity.
// If the Test object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TestMutation) OldMode(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMode: %w", err)
	}
	return oldValue.Mode, nil
}

// AddMode adds i to the "mode" field.
func (m *TestMutation) AddMode(i int) {
	if m.addmode != nil {
		*m.addmode += i
	} else {
		m.addmode = &i
	}
}

// AddedMode returns the value that was added to the "mode" field in this mutation.
func (m *TestMutation) AddedMode() (r int, exists bool) {
	v := m.addmode
	if v == nil {
		return
	}
	return *v, true
}

// ResetMode resets all changes to the "mode" field.
func (m *TestMutation) ResetMode() {
	m.mode = nil
	m.addmode = nil
}

// SetSelfPickupConfigs sets the "self_pickup_configs" field.
func (m *TestMutation) SetSelfPickupConfigs(spc schema.SelfPickupConfig) {
	m.self_pickup_configs = &spc
}

// SelfPickupConfigs returns the value of the "self_pickup_configs" field in the mutation.
func (m *TestMutation) SelfPickupConfigs() (r schema.SelfPickupConfig, exists bool) {
	v := m.self_pickup_configs
	if v == nil {
		return
	}
	return *v, true
}

// OldSelfPickupConfigs returns the old "self_pickup_configs" field's value of the Test entity.
// If the Test object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TestMutation) OldSelfPickupConfigs(ctx context.Context) (v schema.SelfPickupConfig, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSelfPickupConfigs is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSelfPickupConfigs requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSelfPickupConfigs: %w", err)
	}
	return oldValue.SelfPickupConfigs, nil
}

// ResetSelfPickupConfigs resets all changes to the "self_pickup_configs" field.
func (m *TestMutation) ResetSelfPickupConfigs() {
	m.self_pickup_configs = nil
}

// SetServerID sets the "server_id" field.
func (m *TestMutation) SetServerID(i int) {
	m.server_id = &i
	m.addserver_id = nil
}

// ServerID returns the value of the "server_id" field in the mutation.
func (m *TestMutation) ServerID() (r int, exists bool) {
	v := m.server_id
	if v == nil {
		return
	}
	return *v, true
}

// OldServerID returns the old "server_id" field's value of the Test entity.
// If the Test object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TestMutation) OldServerID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldServerID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldServerID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldServerID: %w", err)
	}
	return oldValue.ServerID, nil
}

// AddServerID adds i to the "server_id" field.
func (m *TestMutation) AddServerID(i int) {
	if m.addserver_id != nil {
		*m.addserver_id += i
	} else {
		m.addserver_id = &i
	}
}

// AddedServerID returns the value that was added to the "server_id" field in this mutation.
func (m *TestMutation) AddedServerID() (r int, exists bool) {
	v := m.addserver_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetServerID resets all changes to the "server_id" field.
func (m *TestMutation) ResetServerID() {
	m.server_id = nil
	m.addserver_id = nil
}

// SetImage sets the "image" field.
func (m *TestMutation) SetImage(s string) {
	m.image = &s
}

// Image returns the value of the "image" field in the mutation.
func (m *TestMutation) Image() (r string, exists bool) {
	v := m.image
	if v == nil {
		return
	}
	return *v, true
}

// OldImage returns the old "image" field's value of the Test entity.
// If the Test object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TestMutation) OldImage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldImage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldImage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldImage: %w", err)
	}
	return oldValue.Image, nil
}

// ResetImage resets all changes to the "image" field.
func (m *TestMutation) ResetImage() {
	m.image = nil
}

// SetAddress sets the "address" field.
func (m *TestMutation) SetAddress(s string) {
	m.address = &s
}

// Address returns the value of the "address" field in the mutation.
func (m *TestMutation) Address() (r string, exists bool) {
	v := m.address
	if v == nil {
		return
	}
	return *v, true
}

// OldAddress returns the old "address" field's value of the Test entity.
// If the Test object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TestMutation) OldAddress(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAddress: %w", err)
	}
	return oldValue.Address, nil
}

// ResetAddress resets all changes to the "address" field.
func (m *TestMutation) ResetAddress() {
	m.address = nil
}

// SetLatitude sets the "latitude" field.
func (m *TestMutation) SetLatitude(s string) {
	m.latitude = &s
}

// Latitude returns the value of the "latitude" field in the mutation.
func (m *TestMutation) Latitude() (r string, exists bool) {
	v := m.latitude
	if v == nil {
		return
	}
	return *v, true
}

// OldLatitude returns the old "latitude" field's value of the Test entity.
// If the Test object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TestMutation) OldLatitude(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLatitude is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLatitude requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLatitude: %w", err)
	}
	return oldValue.Latitude, nil
}

// ResetLatitude resets all changes to the "latitude" field.
func (m *TestMutation) ResetLatitude() {
	m.latitude = nil
}

// SetLongitude sets the "longitude" field.
func (m *TestMutation) SetLongitude(s string) {
	m.longitude = &s
}

// Longitude returns the value of the "longitude" field in the mutation.
func (m *TestMutation) Longitude() (r string, exists bool) {
	v := m.longitude
	if v == nil {
		return
	}
	return *v, true
}

// OldLongitude returns the old "longitude" field's value of the Test entity.
// If the Test object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TestMutation) OldLongitude(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLongitude is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLongitude requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLongitude: %w", err)
	}
	return oldValue.Longitude, nil
}

// ResetLongitude resets all changes to the "longitude" field.
func (m *TestMutation) ResetLongitude() {
	m.longitude = nil
}

// SetBanners sets the "banners" field.
func (m *TestMutation) SetBanners(s schema.Banners) {
	m.banners = &s
}

// Banners returns the value of the "banners" field in the mutation.
func (m *TestMutation) Banners() (r schema.Banners, exists bool) {
	v := m.banners
	if v == nil {
		return
	}
	return *v, true
}

// OldBanners returns the old "banners" field's value of the Test entity.
// If the Test object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TestMutation) OldBanners(ctx context.Context) (v schema.Banners, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBanners is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBanners requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBanners: %w", err)
	}
	return oldValue.Banners, nil
}

// ResetBanners resets all changes to the "banners" field.
func (m *TestMutation) ResetBanners() {
	m.banners = nil
}

// SetSort sets the "sort" field.
func (m *TestMutation) SetSort(i int) {
	m.sort = &i
	m.addsort = nil
}

// Sort returns the value of the "sort" field in the mutation.
func (m *TestMutation) Sort() (r int, exists bool) {
	v := m.sort
	if v == nil {
		return
	}
	return *v, true
}

// OldSort returns the old "sort" field's value of the Test entity.
// If the Test object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TestMutation) OldSort(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSort is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSort requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSort: %w", err)
	}
	return oldValue.Sort, nil
}

// AddSort adds i to the "sort" field.
func (m *TestMutation) AddSort(i int) {
	if m.addsort != nil {
		*m.addsort += i
	} else {
		m.addsort = &i
	}
}

// AddedSort returns the value that was added to the "sort" field in this mutation.
func (m *TestMutation) AddedSort() (r int, exists bool) {
	v := m.addsort
	if v == nil {
		return
	}
	return *v, true
}

// ResetSort resets all changes to the "sort" field.
func (m *TestMutation) ResetSort() {
	m.sort = nil
	m.addsort = nil
}

// SetPayMode sets the "pay_mode" field.
func (m *TestMutation) SetPayMode(s string) {
	m.pay_mode = &s
}

// PayMode returns the value of the "pay_mode" field in the mutation.
func (m *TestMutation) PayMode() (r string, exists bool) {
	v := m.pay_mode
	if v == nil {
		return
	}
	return *v, true
}

// OldPayMode returns the old "pay_mode" field's value of the Test entity.
// If the Test object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TestMutation) OldPayMode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPayMode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPayMode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPayMode: %w", err)
	}
	return oldValue.PayMode, nil
}

// ResetPayMode resets all changes to the "pay_mode" field.
func (m *TestMutation) ResetPayMode() {
	m.pay_mode = nil
}

// SetDineInConfigs sets the "dine_in_configs" field.
func (m *TestMutation) SetDineInConfigs(sic schema.DineInConfigs) {
	m.dine_in_configs = &sic
}

// DineInConfigs returns the value of the "dine_in_configs" field in the mutation.
func (m *TestMutation) DineInConfigs() (r schema.DineInConfigs, exists bool) {
	v := m.dine_in_configs
	if v == nil {
		return
	}
	return *v, true
}

// OldDineInConfigs returns the old "dine_in_configs" field's value of the Test entity.
// If the Test object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TestMutation) OldDineInConfigs(ctx context.Context) (v schema.DineInConfigs, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDineInConfigs is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDineInConfigs requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDineInConfigs: %w", err)
	}
	return oldValue.DineInConfigs, nil
}

// ClearDineInConfigs clears the value of the "dine_in_configs" field.
func (m *TestMutation) ClearDineInConfigs() {
	m.dine_in_configs = nil
	m.clearedFields[test.FieldDineInConfigs] = struct{}{}
}

// DineInConfigsCleared returns if the "dine_in_configs" field was cleared in this mutation.
func (m *TestMutation) DineInConfigsCleared() bool {
	_, ok := m.clearedFields[test.FieldDineInConfigs]
	return ok
}

// ResetDineInConfigs resets all changes to the "dine_in_configs" field.
func (m *TestMutation) ResetDineInConfigs() {
	m.dine_in_configs = nil
	delete(m.clearedFields, test.FieldDineInConfigs)
}

// SetDealsConfig sets the "deals_config" field.
func (m *TestMutation) SetDealsConfig(sc schema.DealsConfig) {
	m.deals_config = &sc
}

// DealsConfig returns the value of the "deals_config" field in the mutation.
func (m *TestMutation) DealsConfig() (r schema.DealsConfig, exists bool) {
	v := m.deals_config
	if v == nil {
		return
	}
	return *v, true
}

// OldDealsConfig returns the old "deals_config" field's value of the Test entity.
// If the Test object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TestMutation) OldDealsConfig(ctx context.Context) (v schema.DealsConfig, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDealsConfig is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDealsConfig requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDealsConfig: %w", err)
	}
	return oldValue.DealsConfig, nil
}

// ClearDealsConfig clears the value of the "deals_config" field.
func (m *TestMutation) ClearDealsConfig() {
	m.deals_config = nil
	m.clearedFields[test.FieldDealsConfig] = struct{}{}
}

// DealsConfigCleared returns if the "deals_config" field was cleared in this mutation.
func (m *TestMutation) DealsConfigCleared() bool {
	_, ok := m.clearedFields[test.FieldDealsConfig]
	return ok
}

// ResetDealsConfig resets all changes to the "deals_config" field.
func (m *TestMutation) ResetDealsConfig() {
	m.deals_config = nil
	delete(m.clearedFields, test.FieldDealsConfig)
}

// SetPrintConfig sets the "print_config" field.
func (m *TestMutation) SetPrintConfig(sc schema.PrintConfig) {
	m.print_config = &sc
}

// PrintConfig returns the value of the "print_config" field in the mutation.
func (m *TestMutation) PrintConfig() (r schema.PrintConfig, exists bool) {
	v := m.print_config
	if v == nil {
		return
	}
	return *v, true
}

// OldPrintConfig returns the old "print_config" field's value of the Test entity.
// If the Test object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TestMutation) OldPrintConfig(ctx context.Context) (v schema.PrintConfig, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPrintConfig is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPrintConfig requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPrintConfig: %w", err)
	}
	return oldValue.PrintConfig, nil
}

// ClearPrintConfig clears the value of the "print_config" field.
func (m *TestMutation) ClearPrintConfig() {
	m.print_config = nil
	m.clearedFields[test.FieldPrintConfig] = struct{}{}
}

// PrintConfigCleared returns if the "print_config" field was cleared in this mutation.
func (m *TestMutation) PrintConfigCleared() bool {
	_, ok := m.clearedFields[test.FieldPrintConfig]
	return ok
}

// ResetPrintConfig resets all changes to the "print_config" field.
func (m *TestMutation) ResetPrintConfig() {
	m.print_config = nil
	delete(m.clearedFields, test.FieldPrintConfig)
}

// Where appends a list predicates to the TestMutation builder.
func (m *TestMutation) Where(ps ...predicate.Test) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *TestMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Test).
func (m *TestMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TestMutation) Fields() []string {
	fields := make([]string, 0, 30)
	if m.uid != nil {
		fields = append(fields, test.FieldUID)
	}
	if m.created_at != nil {
		fields = append(fields, test.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, test.FieldUpdatedAt)
	}
	if m.deactivated_at != nil {
		fields = append(fields, test.FieldDeactivatedAt)
	}
	if m.name != nil {
		fields = append(fields, test.FieldName)
	}
	if m.enable_takeaway != nil {
		fields = append(fields, test.FieldEnableTakeaway)
	}
	if m.phone != nil {
		fields = append(fields, test.FieldPhone)
	}
	if m.announcement != nil {
		fields = append(fields, test.FieldAnnouncement)
	}
	if m.enable_auto_accept != nil {
		fields = append(fields, test.FieldEnableAutoAccept)
	}
	if m.delivery_configs != nil {
		fields = append(fields, test.FieldDeliveryConfigs)
	}
	if m.pay_configs != nil {
		fields = append(fields, test.FieldPayConfigs)
	}
	if m.print_times != nil {
		fields = append(fields, test.FieldPrintTimes)
	}
	if m.ring_configs != nil {
		fields = append(fields, test.FieldRingConfigs)
	}
	if m.business_group_id != nil {
		fields = append(fields, test.FieldBusinessGroupID)
	}
	if m.business_group_uid != nil {
		fields = append(fields, test.FieldBusinessGroupUID)
	}
	if m.dish_categories != nil {
		fields = append(fields, test.FieldDishCategories)
	}
	if m.end_of_takeaway != nil {
		fields = append(fields, test.FieldEndOfTakeaway)
	}
	if m.mode != nil {
		fields = append(fields, test.FieldMode)
	}
	if m.self_pickup_configs != nil {
		fields = append(fields, test.FieldSelfPickupConfigs)
	}
	if m.server_id != nil {
		fields = append(fields, test.FieldServerID)
	}
	if m.image != nil {
		fields = append(fields, test.FieldImage)
	}
	if m.address != nil {
		fields = append(fields, test.FieldAddress)
	}
	if m.latitude != nil {
		fields = append(fields, test.FieldLatitude)
	}
	if m.longitude != nil {
		fields = append(fields, test.FieldLongitude)
	}
	if m.banners != nil {
		fields = append(fields, test.FieldBanners)
	}
	if m.sort != nil {
		fields = append(fields, test.FieldSort)
	}
	if m.pay_mode != nil {
		fields = append(fields, test.FieldPayMode)
	}
	if m.dine_in_configs != nil {
		fields = append(fields, test.FieldDineInConfigs)
	}
	if m.deals_config != nil {
		fields = append(fields, test.FieldDealsConfig)
	}
	if m.print_config != nil {
		fields = append(fields, test.FieldPrintConfig)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TestMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case test.FieldUID:
		return m.UID()
	case test.FieldCreatedAt:
		return m.CreatedAt()
	case test.FieldUpdatedAt:
		return m.UpdatedAt()
	case test.FieldDeactivatedAt:
		return m.DeactivatedAt()
	case test.FieldName:
		return m.Name()
	case test.FieldEnableTakeaway:
		return m.EnableTakeaway()
	case test.FieldPhone:
		return m.Phone()
	case test.FieldAnnouncement:
		return m.Announcement()
	case test.FieldEnableAutoAccept:
		return m.EnableAutoAccept()
	case test.FieldDeliveryConfigs:
		return m.DeliveryConfigs()
	case test.FieldPayConfigs:
		return m.PayConfigs()
	case test.FieldPrintTimes:
		return m.PrintTimes()
	case test.FieldRingConfigs:
		return m.RingConfigs()
	case test.FieldBusinessGroupID:
		return m.BusinessGroupID()
	case test.FieldBusinessGroupUID:
		return m.BusinessGroupUID()
	case test.FieldDishCategories:
		return m.DishCategories()
	case test.FieldEndOfTakeaway:
		return m.EndOfTakeaway()
	case test.FieldMode:
		return m.Mode()
	case test.FieldSelfPickupConfigs:
		return m.SelfPickupConfigs()
	case test.FieldServerID:
		return m.ServerID()
	case test.FieldImage:
		return m.Image()
	case test.FieldAddress:
		return m.Address()
	case test.FieldLatitude:
		return m.Latitude()
	case test.FieldLongitude:
		return m.Longitude()
	case test.FieldBanners:
		return m.Banners()
	case test.FieldSort:
		return m.Sort()
	case test.FieldPayMode:
		return m.PayMode()
	case test.FieldDineInConfigs:
		return m.DineInConfigs()
	case test.FieldDealsConfig:
		return m.DealsConfig()
	case test.FieldPrintConfig:
		return m.PrintConfig()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TestMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case test.FieldUID:
		return m.OldUID(ctx)
	case test.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case test.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case test.FieldDeactivatedAt:
		return m.OldDeactivatedAt(ctx)
	case test.FieldName:
		return m.OldName(ctx)
	case test.FieldEnableTakeaway:
		return m.OldEnableTakeaway(ctx)
	case test.FieldPhone:
		return m.OldPhone(ctx)
	case test.FieldAnnouncement:
		return m.OldAnnouncement(ctx)
	case test.FieldEnableAutoAccept:
		return m.OldEnableAutoAccept(ctx)
	case test.FieldDeliveryConfigs:
		return m.OldDeliveryConfigs(ctx)
	case test.FieldPayConfigs:
		return m.OldPayConfigs(ctx)
	case test.FieldPrintTimes:
		return m.OldPrintTimes(ctx)
	case test.FieldRingConfigs:
		return m.OldRingConfigs(ctx)
	case test.FieldBusinessGroupID:
		return m.OldBusinessGroupID(ctx)
	case test.FieldBusinessGroupUID:
		return m.OldBusinessGroupUID(ctx)
	case test.FieldDishCategories:
		return m.OldDishCategories(ctx)
	case test.FieldEndOfTakeaway:
		return m.OldEndOfTakeaway(ctx)
	case test.FieldMode:
		return m.OldMode(ctx)
	case test.FieldSelfPickupConfigs:
		return m.OldSelfPickupConfigs(ctx)
	case test.FieldServerID:
		return m.OldServerID(ctx)
	case test.FieldImage:
		return m.OldImage(ctx)
	case test.FieldAddress:
		return m.OldAddress(ctx)
	case test.FieldLatitude:
		return m.OldLatitude(ctx)
	case test.FieldLongitude:
		return m.OldLongitude(ctx)
	case test.FieldBanners:
		return m.OldBanners(ctx)
	case test.FieldSort:
		return m.OldSort(ctx)
	case test.FieldPayMode:
		return m.OldPayMode(ctx)
	case test.FieldDineInConfigs:
		return m.OldDineInConfigs(ctx)
	case test.FieldDealsConfig:
		return m.OldDealsConfig(ctx)
	case test.FieldPrintConfig:
		return m.OldPrintConfig(ctx)
	}
	return nil, fmt.Errorf("unknown Test field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TestMutation) SetField(name string, value ent.Value) error {
	switch name {
	case test.FieldUID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUID(v)
		return nil
	case test.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case test.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case test.FieldDeactivatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeactivatedAt(v)
		return nil
	case test.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case test.FieldEnableTakeaway:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEnableTakeaway(v)
		return nil
	case test.FieldPhone:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPhone(v)
		return nil
	case test.FieldAnnouncement:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAnnouncement(v)
		return nil
	case test.FieldEnableAutoAccept:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEnableAutoAccept(v)
		return nil
	case test.FieldDeliveryConfigs:
		v, ok := value.(schema.DeliveryConfig)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeliveryConfigs(v)
		return nil
	case test.FieldPayConfigs:
		v, ok := value.(schema.PayConfig)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPayConfigs(v)
		return nil
	case test.FieldPrintTimes:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPrintTimes(v)
		return nil
	case test.FieldRingConfigs:
		v, ok := value.(schema.RingConfig)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRingConfigs(v)
		return nil
	case test.FieldBusinessGroupID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBusinessGroupID(v)
		return nil
	case test.FieldBusinessGroupUID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBusinessGroupUID(v)
		return nil
	case test.FieldDishCategories:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDishCategories(v)
		return nil
	case test.FieldEndOfTakeaway:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEndOfTakeaway(v)
		return nil
	case test.FieldMode:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMode(v)
		return nil
	case test.FieldSelfPickupConfigs:
		v, ok := value.(schema.SelfPickupConfig)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSelfPickupConfigs(v)
		return nil
	case test.FieldServerID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetServerID(v)
		return nil
	case test.FieldImage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetImage(v)
		return nil
	case test.FieldAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAddress(v)
		return nil
	case test.FieldLatitude:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLatitude(v)
		return nil
	case test.FieldLongitude:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLongitude(v)
		return nil
	case test.FieldBanners:
		v, ok := value.(schema.Banners)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBanners(v)
		return nil
	case test.FieldSort:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSort(v)
		return nil
	case test.FieldPayMode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPayMode(v)
		return nil
	case test.FieldDineInConfigs:
		v, ok := value.(schema.DineInConfigs)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDineInConfigs(v)
		return nil
	case test.FieldDealsConfig:
		v, ok := value.(schema.DealsConfig)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDealsConfig(v)
		return nil
	case test.FieldPrintConfig:
		v, ok := value.(schema.PrintConfig)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPrintConfig(v)
		return nil
	}
	return fmt.Errorf("unknown Test field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TestMutation) AddedFields() []string {
	var fields []string
	if m.addprint_times != nil {
		fields = append(fields, test.FieldPrintTimes)
	}
	if m.addbusiness_group_id != nil {
		fields = append(fields, test.FieldBusinessGroupID)
	}
	if m.addmode != nil {
		fields = append(fields, test.FieldMode)
	}
	if m.addserver_id != nil {
		fields = append(fields, test.FieldServerID)
	}
	if m.addsort != nil {
		fields = append(fields, test.FieldSort)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TestMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case test.FieldPrintTimes:
		return m.AddedPrintTimes()
	case test.FieldBusinessGroupID:
		return m.AddedBusinessGroupID()
	case test.FieldMode:
		return m.AddedMode()
	case test.FieldServerID:
		return m.AddedServerID()
	case test.FieldSort:
		return m.AddedSort()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TestMutation) AddField(name string, value ent.Value) error {
	switch name {
	case test.FieldPrintTimes:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPrintTimes(v)
		return nil
	case test.FieldBusinessGroupID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddBusinessGroupID(v)
		return nil
	case test.FieldMode:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMode(v)
		return nil
	case test.FieldServerID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddServerID(v)
		return nil
	case test.FieldSort:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSort(v)
		return nil
	}
	return fmt.Errorf("unknown Test numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TestMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(test.FieldDeactivatedAt) {
		fields = append(fields, test.FieldDeactivatedAt)
	}
	if m.FieldCleared(test.FieldPrintTimes) {
		fields = append(fields, test.FieldPrintTimes)
	}
	if m.FieldCleared(test.FieldEndOfTakeaway) {
		fields = append(fields, test.FieldEndOfTakeaway)
	}
	if m.FieldCleared(test.FieldDineInConfigs) {
		fields = append(fields, test.FieldDineInConfigs)
	}
	if m.FieldCleared(test.FieldDealsConfig) {
		fields = append(fields, test.FieldDealsConfig)
	}
	if m.FieldCleared(test.FieldPrintConfig) {
		fields = append(fields, test.FieldPrintConfig)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TestMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TestMutation) ClearField(name string) error {
	switch name {
	case test.FieldDeactivatedAt:
		m.ClearDeactivatedAt()
		return nil
	case test.FieldPrintTimes:
		m.ClearPrintTimes()
		return nil
	case test.FieldEndOfTakeaway:
		m.ClearEndOfTakeaway()
		return nil
	case test.FieldDineInConfigs:
		m.ClearDineInConfigs()
		return nil
	case test.FieldDealsConfig:
		m.ClearDealsConfig()
		return nil
	case test.FieldPrintConfig:
		m.ClearPrintConfig()
		return nil
	}
	return fmt.Errorf("unknown Test nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TestMutation) ResetField(name string) error {
	switch name {
	case test.FieldUID:
		m.ResetUID()
		return nil
	case test.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case test.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case test.FieldDeactivatedAt:
		m.ResetDeactivatedAt()
		return nil
	case test.FieldName:
		m.ResetName()
		return nil
	case test.FieldEnableTakeaway:
		m.ResetEnableTakeaway()
		return nil
	case test.FieldPhone:
		m.ResetPhone()
		return nil
	case test.FieldAnnouncement:
		m.ResetAnnouncement()
		return nil
	case test.FieldEnableAutoAccept:
		m.ResetEnableAutoAccept()
		return nil
	case test.FieldDeliveryConfigs:
		m.ResetDeliveryConfigs()
		return nil
	case test.FieldPayConfigs:
		m.ResetPayConfigs()
		return nil
	case test.FieldPrintTimes:
		m.ResetPrintTimes()
		return nil
	case test.FieldRingConfigs:
		m.ResetRingConfigs()
		return nil
	case test.FieldBusinessGroupID:
		m.ResetBusinessGroupID()
		return nil
	case test.FieldBusinessGroupUID:
		m.ResetBusinessGroupUID()
		return nil
	case test.FieldDishCategories:
		m.ResetDishCategories()
		return nil
	case test.FieldEndOfTakeaway:
		m.ResetEndOfTakeaway()
		return nil
	case test.FieldMode:
		m.ResetMode()
		return nil
	case test.FieldSelfPickupConfigs:
		m.ResetSelfPickupConfigs()
		return nil
	case test.FieldServerID:
		m.ResetServerID()
		return nil
	case test.FieldImage:
		m.ResetImage()
		return nil
	case test.FieldAddress:
		m.ResetAddress()
		return nil
	case test.FieldLatitude:
		m.ResetLatitude()
		return nil
	case test.FieldLongitude:
		m.ResetLongitude()
		return nil
	case test.FieldBanners:
		m.ResetBanners()
		return nil
	case test.FieldSort:
		m.ResetSort()
		return nil
	case test.FieldPayMode:
		m.ResetPayMode()
		return nil
	case test.FieldDineInConfigs:
		m.ResetDineInConfigs()
		return nil
	case test.FieldDealsConfig:
		m.ResetDealsConfig()
		return nil
	case test.FieldPrintConfig:
		m.ResetPrintConfig()
		return nil
	}
	return fmt.Errorf("unknown Test field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TestMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TestMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TestMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TestMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TestMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TestMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TestMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Test unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TestMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Test edge %s", name)
}
